@[TOC](新闻爬虫及爬取结果的查询网站)

完整代码可以访问[GitHub链接](https://github.com/qifeng1128/WebFinalProject)

## 实验要求

基于第一个项目爬虫爬取的数据，完成数据展示网站

### 一、基本要求

1、用户可注册登录网站，非注册用户不可登录查看数据
2、用户注册、登录、查询等操作记入数据库中的日志
3、爬虫数据查询结果列表支持分页和排序
4、用Echarts或者D3实现3个以上的数据分析图表展示在网站中
5、实现一个管理端界面，可以查看（查看用户的操作记录）和管理（停用启用）注册用户

### 二、扩展要求

1、实现对爬虫数据中文分词的查询
2、实现查询结果按照主题词打分的排序
3、用Elastic Search+Kibana展示爬虫的数据结果

（对于扩展要求，这次只实现了前两个要求，由于对Elastic Search的使用不太熟悉和时间较紧，所以第三个要求并未完成）

## 结果展示

[demo展示](https://www.bilibili.com/video/BV1nw411o7hb)

## 实验过程

由于【要求三：查询结果支持分页和排序】在第一次大作业中已经实现了，所以这里不详细讲解实现过程，仅展示一下实现结果

当返回符合的新闻条数过多时，将对结果进行分页，便于用户进行查看。与此同时，用户也可以根据标题、刊登日期和参与人数等字段进行升序或降序排列

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210627135053835.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTcxNjg5MQ==,size_16,color_FFFFFF,t_70#pic_center)


### 一、注册登录网站

#### 1、记录用户信息表结构

存储注册成功的用户名及其对应的密码（为了确保用户名唯一，将其设置为主键）

```sql
CREATE TABLE IF NOT EXISTS `user_info` (
  `username` varchar(200) ,
  `password` varchar(200) DEFAULT NULL,
  PRIMARY KEY (`username`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210627135136479.png#pic_center)


#### 2、用户注册前端（register.html)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210627135155513.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTcxNjg5MQ==,size_16,color_FFFFFF,t_70#pic_center)


在注册页面，向用户提供了两个输入文本框，包括用户名（昵称）和密码，以及一个注册按钮，用户点击按钮后，将实现页面转跳

前端网页代码：

```html
<!doctype html>
<html>
<head>
    <script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.js"></script>
    <link rel="stylesheet" href="login.css">
    <meta charset="utf-8">
    <title>注册界面</title>
</head>
<body>
    <div class="wrapper">
        <div class="loginBox">
            <div class="loginBoxCenter">
                <h1 align="center">用户注册</h1>

                <p>用户名：</p>
                <p><input type="text" id="username" class="loginInput" placeholder="请输入昵称"></p>

                <p>密码：</p>
                <p><input type="password" id="password" class="loginInput" placeholder="请输入密码"></p>

            </div>

            <div class="loginBoxButtons">

                <button type="button" class="loginBtn" onclick="userLogin()">注册</button>
                <script>
                    function userLogin(){
                        var username = document.getElementById("username")
                        var password = document.getElementById("password")

                        // 将用户名和密码传递至user_register路由，从而判断用户是否已经注册
                        $.ajax({
                            url: "/user_register",
                            async: false,        //这一步是非常重要的，作用是设置为同步执行
                            type: "POST",
                            data: { name:username.value,pwd:password.value },
                            dataType: "json",
                            success: function (data) {
                                // 后端传递内容的类型为object，直接进行解析
                                console.log(typeof(data))
                                console.log(data)
                                var status = data['status']
                                window.alert(status)
                                if (status == "please input your username or password") {
                                    // 用户未输入用户名或密码，继续停留在注册界面
                                    window.location.href = "http://localhost:3000/register.html"
                                }
                                else{
                                    // 转跳登录页面   
                                window.location.href = "http://localhost:3000/login.html"
                                }
                                
                            }
                        })
                    }
                </script>

            </div>
        </div>
    </div>
</body>

</html>
```

其中使用了POST方法，将用户名和密码两个参数传递到user_register路由，判断用户是否已经注册，将路由返回的消息通过window.alert以警告框的形式展现在前端页面，若用户未进行注册，则将注册成功并转跳登录页面，若用户已经注册过，则可直接进行登录，转跳登陆页面，若用户未输入用户名或密码，将转跳注册页面

前端CSS样式：

```css
html {
    background-image: url(login.png)
}

.wrapper {
    margin: 140px 0 140px auto;
    width: 884px;
}

.loginBox {
    background-color: #F0F4F6;
    /*上divcolor*/
    border: 1px solid #BfD6E1;
    border-radius: 5px;
    color: #444;
    font: 14px 'Microsoft YaHei', '微软雅黑';
    margin: 0 auto;
    width: 388px
}

.loginBox .loginBoxCenter {
    border-bottom: 1px solid #DDE0E8;
    padding: 24px;
}

.loginBox .loginBoxCenter p {
    margin-bottom: 10px
}

.loginBox .loginBoxButtons {
    /*background-color: #F0F4F6;*/
    /*下divcolor*/
    border-top: 0px solid #FFF;
    border-bottom-left-radius: 5px;
    border-bottom-right-radius: 5px;
    line-height: 28px;
    overflow: hidden;
    padding: 20px 24px;
    vertical-align: center;
    filter: alpha(Opacity=80);
    -moz-opacity: 0.5;
    opacity: 0.5;
}

.loginBox .loginInput {
    border: 1px solid #D2D9dC;
    border-radius: 2px;
    color: #444;
    font: 12px 'Microsoft YaHei', '微软雅黑';
    padding: 8px 14px;
    margin-bottom: 8px;
    width: 310px;
}

.loginBox .loginInput:FOCUS {
    border: 1px solid #B7D4EA;
    box-shadow: 0 0 8px #B7D4EA;
}

.loginBox .loginBtn {
    background-image: -moz-linear-gradient(to bottom, blue, #85CFEE);
    border: 1px solid #98CCE7;
    border-radius: 20px;
    box-shadow: inset rgba(255, 255, 255, 0.6) 0 1px 1px, rgba(0, 0, 0, 0.1) 0 1px 1px;
    color: #444;
    /*登录*/
    cursor: pointer;
    float: right;
    font: bold 13px Arial;
    padding: 10px 50px;
}

.loginBox .loginBtn:HOVER {
    background-image: -moz-linear-gradient(to top, blue, #85CFEE);
}

.loginBox a.forgetLink {
    color: #ABABAB;
    cursor: pointer;
    float: right;
    font: 11px/20px Arial;
    text-decoration: none;
    vertical-align: middle;
    /*忘记密码*/
}

.loginBox a.forgetLink:HOVER {
    color: #000000;
    text-decoration: none;
    /*忘记密码*/
}

.loginBox input#remember {
    vertical-align: middle;
}

.loginBox label[for="remember"] {
    font: 11px Arial;
}
```

#### 3、用户注册后端

通过request.body获得用户的用户名username和密码password，先判断用户输入的用户名或密码是否为空，若为空，返回 “please input your username or password” 信息，再从数据库中的表user_info查询username是否存在，若username存在，表示用户已经注册过或者用户名重复，返回 “the username is duplicated” 信息，若username不存在，则将用户注册的昵称和密码插入user_info表中，返回 “register success" 信息

```js
// 判断用户是否注册过
router.post('/user_register', urlencodedParser, function(request, response) {

    // 获得用户输入的用户名和密码
    var username = request.body.name
    var password = request.body.pwd

    var tempt = {}

    console.log(typeof(username))
    console.log(password)
    // 判断用户注册的昵称和密码是否为空
    if (username.length == 0 || password.length == 0){
        tempt.status = 'please input your username or password'
        response.end(JSON.stringify(tempt))
        return
    }
    
    // 从数据库中查询username是否存在
    var fetch_username_Sql = 'select username,password from user_info where username=?'  
    var fetch_username_Sql_Params = [username]  

    // 调用mysql文件中的query模块（具有参数的数据库语句查询）
    mysql.query(fetch_username_Sql, fetch_username_Sql_Params, function(err, result) {
        console.log(result)
        if (err) console.log(err)
        // user表中保证用户名不重复，只可能不返回数据或返回一条数据
        if (result.length > 0) {
            // 用户已经注册过或者用户名重复
            tempt.status = 'the username is duplicated'
            response.end(JSON.stringify(tempt))
            return
        }else{
            // 添加用户注册日志
            var operation = "用户注册"
            var insertSql = 'INSERT INTO user_log(username,operation,time)' + ' VALUES (?,?,now())'
            var insertSql_Params = [username,operation] 
            mysql.query(insertSql, insertSql_Params, function(err, result, fields) {
                if (err) console.log(err)
            })
            // 用户注册成功
            tempt.status = 'register success'
            // 在user_info表中插入信息
            var fetchAddSql = 'INSERT INTO user_info(username,password) VALUES(?,?)'
            // 插入语句中相应的参数
            var fetchAddSql_Params = [username,password]
            // 执行sql
            mysql.query(fetchAddSql, fetchAddSql_Params, function(err, result) {
                if (err) {
                    console.log(err)
                }
            })     //mysql写入
            response.end(JSON.stringify(tempt))
            return
        }
    })
})
```

#### 4、用户登录前端（login.html）

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210627135215514.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTcxNjg5MQ==,size_16,color_FFFFFF,t_70#pic_center)


与用户注册前端相类似，其中css格式相同，不同之处在于增加了选择框表示用户是否记住登录状态、忘记密码文本和新用户注册链接至注册页面register.html

前端网页代码：

```html
<!doctype html>
<html>
<head>
    <script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.js"></script>
    <link rel="stylesheet" href="login.css">
    <meta charset="utf-8">
    <title>登陆界面</title>
</head>
<body>
    <div class="wrapper">
        <div class="loginBox">
            <div class="loginBoxCenter">
                <h1 align="center">用户登录</h1>

                <p>用户名：</p>
                <p><input type="text" id="username" class="loginInput" placeholder="请输入昵称"></p>

                <p>密码：</p>
                <p><input type="password" id="password" class="loginInput" placeholder="请输入密码"></p>

                <p><a class="forgetLink">忘记密码?</a></p>
                
                <input id="remember" type="checkbox" name="remember">
                <label for="remember">记住登录状态</label>
            </div>

            <div class="loginBoxButtons">

                <button type="button" class="loginBtn" onclick="userLogin()">登录</button>
                <script>
                    function userLogin(){
                        var username = document.getElementById("username")
                        var password = document.getElementById("password")

                        // 将用户名和密码传递至user_login路由，从而判断用户是否已经注册
                        $.ajax({
                            url: "/user_login",
                            async: false,        //这一步是非常重要的，作用是设置为同步执行
                            type: "POST",
                            data: { name:username.value,pwd:password.value },
                            dataType: "json",
                            success: function (data) {
                                // 后端传递内容的类型为object，直接进行解析
                                console.log(typeof(data))
                                console.log(data)
                                var status = data['status']
                                window.alert(status)
                                if (status == 'login success') {   // 用户成功登录，转跳到主页面    
                                    window.location.href = "http://localhost:3000/home.html"
                                }else if (status == 'pleasure regist first') {    // 用户未注册，转跳到注册页面
                                    window.location.href = "http://localhost:3000/register.html"
                                }else{      // 用户密码不正确，转跳到登录页面
                                    window.location.href = "http://localhost:3000/login.html"
                                }
                            }
                        })
                    }
                </script>

                <div><a href="/register.html"> 新用户注册</a></div>
            </div>
        </div>
    </div>
</body>

</html>
```

其中使用了POST方法，将用户名和密码两个参数传递到user_login路由，判断用户是否已经注册并且密码是否正确，将路由返回的消息通过window.alert以警告框的形式展现在前端页面，若用户未进行注册，则将转跳注册页面，若用户已经注册过并密码正确，则将转跳主页面，若用户已经注册过但密码不正确，将转跳登录页面

#### 5、用户登录后端

通过request.body获得用户的用户名username和密码password，从数据库中的表user_info查询username是否存在，若username不存在，表示用户未注册成功，无法直接登录，返回 “please register first” 信息，若username存在，则判断用户输入的密码是否正确，若密码不正确，返回 “password is not correct" 信息，若密码正确，返回 ”login success“ 信息

```js
// 判断用户是否可以登录
router.post('/user_login', urlencodedParser, function(request, response) {

    // 获得用户输入的用户名和密码
    var username = request.body.name
    var password = request.body.pwd
    var tempt = {}
    // 从数据库中查询username是否存在
    var fetch_username_Sql = 'select username,password from user_info where username=?'  
    var fetch_username_Sql_Params = [username]  

    // 调用mysql文件中的query模块（具有参数的数据库语句查询）
    mysql.query(fetch_username_Sql, fetch_username_Sql_Params, function(err, result) {
        console.log(result)
        if (err) console.log(err)
        // user表中保证用户名不重复，只可能不返回数据或返回一条数据
        if (result.length > 0) {
            // 查询用户输入的密码是否相同
            var correct_pwd = result[0]['password']
            console.log(correct_pwd)
            console.log(password)
            if (correct_pwd == password){
                 // 添加用户登录日志
                var operation = "用户登录"
                var insertSql = 'INSERT INTO user_log(username,operation,time)' + ' VALUES (?,?,now())'
                var insertSql_Params = [username,operation] 
                mysql.query(insertSql, insertSql_Params, function(err, result, fields) {
                    if (err) console.log(err)
                })
                 // 用户可以登录查看数据
                 tempt.status = 'login success'
                 // 将用户存入cookie中，便于防止非注册用户查看数据
                 response.cookie("username", username)
                 response.end(JSON.stringify(tempt))
                 return
            }else{
                // 输入密码不正确
                tempt.status = 'password is not correct'
                response.end(JSON.stringify(tempt))
                return
            }
        } else {
            // 用户未注册过
            tempt.status = 'please register first'
            response.write(JSON.stringify(tempt))
            response.end()
            return
        }
    })
})
```

#### 6、非注册用户不可查看数据

考虑到一般网站只有登录的用户才能查看数据，所以需要在用户访问数据前先检查他们的身份，判断他们是否已经登录。

最先的实现想法是，通过用户登录成功才能转跳到主页面，再继续查看数据的方式来制止未登录用户查看新闻，但考虑到用户可以直接访问相应的网址来查看数据，所以使用了cookie来记录并获得客户端的用户信息，然后在用户访问查询数据页面时，先通过cookie获取用户信息，判断其是否登录，再将查询页面展示给用户

```js
// 用户可以登录查看数据
tempt.status = 'login success'
// 将用户存入cookie中，便于防止非注册用户查看数据
response.cookie("username", username)
response.end(JSON.stringify(tempt))
```

当用户登录成功时，将其用户名存入cookie中

```html
// 判断用户是否已经登录，若用户未登录，则无法查看数据
$.get('/check', function(data) {
    console.log(data)
    if(data == false) {
        window.alert("please login first");
        window.location.href = "http://localhost:3000/login.html"
    }
})
```

在用户访问查询界面时，先于展示推荐新闻前进行是否登录的判断，通过check路由判断用户是否已经登录，若用户未登录，则将提示信息 ”please login first” ，并且跳转到登录界面

```js
// 判断用户是否已经登录，从而判断其是否可以查看数据
router.get('/check', function(request, response) {

    // 通过cookies获得用户登录时保存的用户名
    var username = request.cookies.username
    var tempt = {}
    if(typeof(username) == undefined) {   // 此时用户未登录
        response.writeHead(200, {
            "Content-Type": "application/json"
        })
        response.write('false')
        response.end()
        return
    } else {    // 判断数据库中是否拥有用户名
        console.log(username)

        var fetch_username_Sql = 'select username,password from user_info where username=?'  
        var fetch_username_Sql_Params = [username]  
    
        // 调用mysql文件中的query模块（具有参数的数据库语句查询）
        mysql.query(fetch_username_Sql, fetch_username_Sql_Params, function(err, result) {
            console.log(result.length)
            if (err) console.log(err)
            // user表中保证用户名不重复，只可能不返回数据或返回一条数据
            if (result.length > 0) {
                // 用户已经登录过了，可以进行数据查看
                response.writeHead(200, {
                    "Content-Type": "application/json"
                })
                response.write('true')
                response.end()
                return
            }
            else{   // 用户未登录
                response.writeHead(200, {
                    "Content-Type": "application/json"
                })
                response.write('false')
                response.end()
                return
            }
        })
    }
})
```

从cookie中获得用户的昵称，若其类型为undefined，则表示其未登录，向前端返回false，表示用户无法查看数据，再判断数据库中user_info表中是否存在用户名，若不存在，同样返回false，表示用户无法查看数据，若存在，则返回true，表示用户可以查看数据

### 二、用户操作记入日志

#### 1、记录用户操作表结构

存储用户的用户名、进行的操作以及进行操作的时间（其中可能存在同一用户在不同时间点进行同一个操作的情况，所以将三者设置为联合主键）

```sql
CREATE TABLE IF NOT EXISTS `user_log` (
  `username` varchar(200) ,
  `operation` varchar(200) ,
  `time` varchar(200) ,
  PRIMARY KEY (`username`,`operation`,`time`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210627135234966.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTcxNjg5MQ==,size_16,color_FFFFFF,t_70#pic_center)


#### 2、注册操作

在用户注册成功时，将用户名、注册操作、当前时间点记录插入user_log表中

```js
// 添加用户注册日志
var operation = "用户注册"
var insertSql = 'INSERT INTO user_log(username,operation,time)' + ' VALUES (?,?,now())'
var insertSql_Params = [username,operation] 
mysql.query(insertSql, insertSql_Params, function(err, result, fields) {
	if (err) console.log(err)
})
```

#### 3、登录操作

在用户登录成功时，将用户名、登录操作、当前时间点记录插入user_log表中

```js
// 添加用户登录日志
var operation = "用户登录"
var insertSql = 'INSERT INTO user_log(username,operation,time)' + ' VALUES (?,?,now())'
var insertSql_Params = [username,operation] 
mysql.query(insertSql, insertSql_Params, function(err, result, fields) {
	if (err) console.log(err)
})
```

#### 4、查询操作

由于存在三种类型的新闻数据并且可以进行新闻数据或词热度分析的查询，因此对于每一种新闻的每一种操作分别进行存储，共六种operation

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210627135251415.png#pic_center)


由于每一种查询操作的日志存储都类似，这里就以查询中国广播网的数据为例，在用户查询数据时，将用户名、登录操作、当前时间点记录插入user_log表中

```js
// 插入用户查询中国广播网数据的操作
var username = request.cookies.username
var operation = "查询中国广播网的数据"
var insertSql = 'INSERT INTO user_log(username,operation,time)' + ' VALUES (?,?,now())'
var insertSql_Params = [username,operation] 
mysql.query(insertSql, insertSql_Params, function(err, result, fields) {
	if (err) console.log(err)
})
```

### 三、数据分析图表

在第一次大作业中，已经实现了通过 **折线图展示时间热度分析** 以及 **柱状图展示查询词热度分析**，这里不多加讲解

（1）查询词的热度分析图表：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210627135302833.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTcxNjg5MQ==,size_16,color_FFFFFF,t_70#pic_center)


![在这里插入图片描述](https://img-blog.csdnimg.cn/20210627135312107.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTcxNjg5MQ==,size_16,color_FFFFFF,t_70#pic_center)


（2）时间热度分析图表（以东方财富网查询 “中国” 为例）：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210627135321985.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTcxNjg5MQ==,size_16,color_FFFFFF,t_70#pic_center)


这次实验中，尝试使用饼状图来展示内容查询词的热度分析，结果如下图所示：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210627135332547.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTcxNjg5MQ==,size_16,color_FFFFFF,t_70#pic_center)


后端返回数据的部分与柱状图绘制时完全一样，只需要修改前端的Echart代码即可

由于饼图中传入数据的格式为 [{value:XXX,name:XXX},{value:XXX,name:XXX}]，所以需在前端将类别名和对应数量组织成以上格式

```html
// 异步加载数据
$.get('/sports_content_info').done(function (result) {
    var the_name = []; //类别数组（用于存放饼图的类别）
    var the_data = [];
    for (var i = 0; i < result[0].length; i++) {
        the_data.push({
            value : result[1][i],
            name : result[0][i]
        });
        the_name.push(result[0][i]);
    }

    myChart2.setOption({
        title: {
            text: '内容查询词的热度分析',
            x:'center'
        },
        tooltip : {
            trigger : 'item',
            formatter : "{a} <br/>{b} : {c} ({d}%)"
        },
        legend: {
            orient : 'vertical',
            left : 'left',
            data: the_name
        },
        series: [{
            name: '频数',
            type: 'pie',
            data: the_data
        }]
    })
})
```

### 四、管理端界面

考虑到管理员的用户名和密码应是先前固定的，他人无法进行注册的，所以这里将其定为（用户名：guanliyuan，密码：123456）

#### 1、修改login页面

在login.html上添加了管理员登录的按钮，只有当用户名为"guanliyuan"和密码为123456时，才能登录成功

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210627135346633.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTcxNjg5MQ==,size_16,color_FFFFFF,t_70#pic_center)


前端修改的代码部分：

```html
<div class="loginBoxButtons">

                <button type="button" class="loginBtn" onclick="userLogin()">登录</button>
                
                <button type="button" class="loginBtn" onclick="administratorLogin()">管理员登录</button>
                
                <script>
                    function userLogin(){
                        var username = document.getElementById("username")
                        var password = document.getElementById("password")

                        // 将用户名和密码传递至user_login路由，从而判断用户是否已经注册
                        $.ajax({
                            url: "/user_login",
                            async: false,        //这一步是非常重要的，作用是设置为同步执行
                            type: "POST",
                            data: { name:username.value,pwd:password.value },
                            dataType: "json",
                            success: function (data) {
                                // 后端传递内容的类型为object，直接进行解析
                                var status = data['status']
                                window.alert(status)
                                if (status == 'login success') {   // 用户成功登录，转跳到主页面    
                                    window.location.href = "http://localhost:3000/home.html"
                                }else if (status == 'please register first') {    // 用户未注册，转跳到注册页面
                                    window.location.href = "http://localhost:3000/register.html"
                                }else{      // 用户密码不正确或账号被管理员禁止，转跳到登录页面
                                    window.location.href = "http://localhost:3000/login.html"
                                }
                            }
                        })
                    }

                    function administratorLogin(){
                        var username = document.getElementById("username")
                        var password = document.getElementById("password")

                        // 将用户名和密码传递至administrator_login路由，从而判断用户是否已经注册
                        $.ajax({
                            url: "/administrator_login",
                            async: false,        //这一步是非常重要的，作用是设置为同步执行
                            type: "POST",
                            data: { name:username.value,pwd:password.value },
                            dataType: "json",
                            success: function (data) {
                                // 后端传递内容的类型为object，直接进行解析
                                var status = data['status']
                                window.alert(status)
                                if (status == 'login success') {   // 用户名与密码正确，转跳到管理员界面
                                    window.location.href = "http://localhost:3000/administrator.html"
                                }else{      // 用户名或密码不正确，转跳登录界面
                                    window.location.href = "http://localhost:3000/login.html"
                                }
                            }
                        })
                    }
                </script>
```

用户点击管理员登录的按钮之后，通过POST方法将用户名和密码两个参数传递到administrator_login路由，判断管理员的用户名和密码是否正确，将路由返回的消息通过window.alert以警告框的形式展现在前端页面，若管理员登录成功，则转跳管理员界面，若未登录成功，则转跳登陆界面

后端路由：

```js
// 判断管理员是否可以登录
router.post('/administrator_login', urlencodedParser, function(request, response) {

    // 获得用户输入的用户名和密码
    var username = request.body.name
    var password = request.body.pwd
    var tempt = {}
    // 判断管理员的用户名和密码是否正确
    if (username == "guanliyuan" && password == "123456"){
        // 保存cookie
        response.cookie("username", username)
        // 用户名与密码正确，转跳到管理员界面
        tempt.status = 'login success'
        response.end(JSON.stringify(tempt))
        return
    }else{
        // 用户名或密码不正确，转跳登录界面
        tempt.status = 'username or password not correct'
        response.end(JSON.stringify(tempt))
        return
    }
})
```

由于管理员的账号和密码是定死的，所以直接判断是否相等即可，当账号和密码正确时，向前端返回"login success"信息，并把用户名存入cookie中，防止不是管理员的其他人访问管理员界面，若账号或密码不正确时，向前端返回"username or password not correct"信息

#### 2、修改user_info表

由于被管理员禁止的用户无法登录，所以在user_info表中增加了ban字段，其为1表示用户被管理员禁止了，其为0表示未被禁止

```sql
CREATE TABLE IF NOT EXISTS `user_info` (
  `username` varchar(200) ,
  `password` varchar(200) DEFAULT NULL,
  `ban` int(11) DEFAULT 0,
  PRIMARY KEY (`username`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210627135405174.png#pic_center)


#### 3、管理员前端（administrator.html）

每当用户访问管理员界面时，均使用check函数判断用户是否为管理员，通过document.cookie获取用户的用户名，判断其是否为"guanliyuan"，若不是，窗口发出"please login first"的警告信息，并转跳到登陆界面，若是管理员，可继续访问管理员界面

```html
<body onload="check()">
    <script>
        // 判断用户是否为管理员，若不是，则转跳到登录界面
        function check() {
            var text = document.cookie
            var username = text.split("=")[1]
            console.log(username)
            if(username != 'guanliyuan') {
                window.alert("please login first");
                window.location.href = "http://localhost:3000/login.html"
            }
        }
    </script>
```

通过访问get_user_operation路由，获取user_log中的用户操作信息，再在前端以表格的形式展现出来

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210627135415148.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTcxNjg5MQ==,size_16,color_FFFFFF,t_70#pic_center)


```html
<h3>
	用户的操作记录：
</h3>

<div class="cardLayout" style="margin: 10px 0px">
	<table width="100%" id="record1"></table>
</div>

<script>
    $(document).ready(function() {

        $.get('/get_user_operation', function(data) {
            $("#record1").empty();

            $("#record1").append('<tr class="cardLayout"><td>username</td><td>operation</td><td>time</td></tr>');
            for (let list of data) {
                let table = '<tr class="cardLayout"><td>';
                Object.values(list).forEach(element => {
                	table += (element + '</td><td>');
                });
            $("#record1").append(table + '</td></tr>');
            }
        })
    });
</script>  
```

通过访问regist_user路由，获取user_log表中的用户名，再在前端以表格的形式展现出来，每个用户旁有停用和启用两个按钮，便于管理员对用户账号进行停用启用操作

![在这里插入图片描述](https://img-blog.csdnimg.cn/2021062713543938.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTcxNjg5MQ==,size_16,color_FFFFFF,t_70#pic_center)


```html
<h3>
    管理注册用户：
</h3>

<div class="cardLayout" style="margin: 10px 0px">
    <table width="100%" id="record2"></table>
</div>

<script>
    $(document).ready(function() {

        $.get('/regist_user', function(data) {
            $("#record2").empty();

            $("#record2").append('<tr class="cardLayout"><td>username</td><td>ban_user</td><td>start_user</td></tr>');
            for (let list of data) {
                let table = '<tr class="cardLayout"><td>';
                Object.values(list).forEach(element => {
                    table += (element + '</td><td>');
                });
                $("#record2").append(table + '<input type="button" id="ban_user" value="停用"></td><td><input type="button" id="start_user" value="启用"></td></tr>');
            }
```

当点击停用按钮，将获取表格这一行中的username，然后将username参数传入ban_user路由，判断是否可以停用这个用户，将后端返回的信息在窗口显示，再转跳到管理员界面

当点击启用按钮，将获取表格这一行中的username，然后将username参数传入start_user路由，判断是否可以启用这个用户，将后端返回的信息在窗口显示，再转跳到管理员界面

```html
$(document).on('click', '#ban_user', function () {
    var username = $(this).parents("tr").find("td").eq(0).text();   //得到用户名
    // 将用户名传递至ban_user路由，从而禁止用户
    $.ajax({
        url: "/ban_user",
        async: false,        //这一步是非常重要的，作用是设置为同步执行
        type: "POST",
        data: { name:username},
        dataType: "json",
        success: function (data) {
            // 后端传递内容的类型为object，直接进行解析
            console.log(typeof(data))
            console.log(data)
            var status = data['status']
            window.alert(status)
            window.location.href = "http://localhost:3000/administrator.html"
        }
    })
})

$(document).on('click', '#start_user', function () {
    var username = $(this).parents("tr").find("td").eq(0).text();   //得到用户名
    // 将用户名传递至ban_user路由，从而禁止用户
    $.ajax({
        url: "/start_user",
        async: false,        //这一步是非常重要的，作用是设置为同步执行
        type: "POST",
        data: { name:username},
        dataType: "json",
        success: function (data) {
        // 后端传递内容的类型为object，直接进行解析
            console.log(typeof(data))
            console.log(data)
            var status = data['status']
            window.alert(status)
            window.location.href = "http://localhost:3000/administrator.html"
        }
    })
})
```

#### 4、管理员后端

get_user_operation路由：

从user_log表中获取用户名、用户操作和时间三个字段，再将结果返回前端

```js
// 返回注册用户的操作
router.get('/get_user_operation', function(request, response) {

    var fetchSql = "select username,operation,time from user_log";
    mysql.query(fetchSql, function(err, result, fields) {
        response.writeHead(200, {
            "Content-Type": "application/json"
        })
        response.status = true;
        response.write(JSON.stringify(result));
        response.end()
    })
})
```

regist_user路由：

从user_log表中获取不重复的用户名，再将结果返回前端

```js
// 返回注册的用户
router.get('/regist_user', function(request, response) {

    var fetchSql = "select distinct username from user_log";
    mysql.query(fetchSql, function(err, result, fields) {
        response.writeHead(200, {
            "Content-Type": "application/json"
        })
        response.status = true;
        response.write(JSON.stringify(result));
        response.end()
    })
})
```

ban_user路由：

通过request.body获取前端传过来的用户名，从user_info表中选取对应用户名的ban字段，若用户已经被停用了（即ban字段为1），则其将无法再停用，向前端返回"you have banned the user"信息，若用户未被停用，则将用户对应的ban字段更新为1，将其禁止，再向前端返回"ban success"信息

```js
// 禁止用户
router.post('/ban_user', urlencodedParser, function(request, response) {

    // 获得用户名
    var username = request.body.name
    var tempt = {}
    // 判断用户是否已经被禁止了
    var fetch_username_Sql = 'select ban from user_info where username=?'  
    var fetch_username_Sql_Params = [username]  

    // 调用mysql文件中的query模块（具有参数的数据库语句查询）
    mysql.query(fetch_username_Sql, fetch_username_Sql_Params, function(err, result) {
        console.log(result)
        if (err) console.log(err)
        var flag = result[0]['ban']
        if (flag == 1){
            // 被管理员禁止
            tempt.status = 'you have banned the user'
            response.end(JSON.stringify(tempt))
            return
        }else{
            // 用户未被禁止，将其禁止
            var update_ban_Sql = 'update user_info set ban=? where username=?'  
            var update_ban_Sql_Params = [1,username]  

            // 调用mysql文件中的query模块（具有参数的数据库语句查询）
            mysql.query(update_ban_Sql, update_ban_Sql_Params, function(err, result) {
                console.log(result)
                if (err) console.log(err)
            })

            // 返回禁止成功语句
            tempt.status = 'ban success'
            response.end(JSON.stringify(tempt))
            return
        }
    })
})
```

start_user路由：

通过request.body获取前端传过来的用户名，从user_info表中选取对应用户名的ban字段，若用户未被停用（即ban字段为0），则无法将其启动，向前端返回"the user is not banned"信息，若用户已停用，则将用户对应的ban字段更新为0，将其启动，再向前端返回"start success"信息

```js
// 启动用户
router.post('/start_user', urlencodedParser, function(request, response) {

    // 获得用户名
    var username = request.body.name
    var tempt = {}
    // 判断用户是否已经被禁止了
    var fetch_username_Sql = 'select ban from user_info where username=?'  
    var fetch_username_Sql_Params = [username]  

    // 调用mysql文件中的query模块（具有参数的数据库语句查询）
    mysql.query(fetch_username_Sql, fetch_username_Sql_Params, function(err, result) {
        console.log(result)
        if (err) console.log(err)
        var flag = result[0]['ban']
        if (flag == 1){
            // 用户被禁止，将其启动
            var update_ban_Sql = 'update user_info set ban=? where username=?'  
            var update_ban_Sql_Params = [0,username]  

            // 调用mysql文件中的query模块（具有参数的数据库语句查询）
            mysql.query(update_ban_Sql, update_ban_Sql_Params, function(err, result) {
                console.log(result)
                if (err) console.log(err)
            })

            // 返回启动成功语句
            tempt.status = 'start success'
            response.end(JSON.stringify(tempt))
            return
        }else{
            // 未被禁止
            tempt.status = 'the user is not banned'
            response.end(JSON.stringify(tempt))
            return
        }
    })
})
```

### 五、中文分词的查询

在查询时，用户可能会输入一段短语进行查询，而新闻内容中与短语完全匹配的可能性较低，从而带来较低的召回率，使得用户体验较差。因此，这里采用中文分词的查询，通过将用户的查询语句进行分词，将与分词后的短语相匹配的内容均返回给用户，虽然查询结果的准确率会降低，但召回率提高了，用户的查询体验会更好

#### 1、分词工具

分词方法采用了基于盘古分词的中文分词模块 node-segment

安装命令：npm install segment --save

具体可参考 github 网址：https://github.com/leizongmin/node-segment

#### 2、主页面修改（home.html）

在主页面增加了进行分词查询的接口

```html
<a class="btn btn-primary" href="/news_split_info.html">分词查询</a>
<a class="btn btn-primary" href="/sports_split_info.html">分词查询</a>
<a class="btn btn-primary" href="/finance_split_info.html">分词查询</a>
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210627135459102.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTcxNjg5MQ==,size_16,color_FFFFFF,t_70#pic_center)


#### 3、分词查询前端（news_split_info.html、sports_split_info.html、finance_split_info.html）

考虑到有些字段内容不包含中文，例如刊登时间，以及有些字段无法进行分词，例如作者，所以这次分词查询选择了 **标题和内容** 两个字段供用户进行复合查询

前端网页 news_split_info.html 与未分词查询的网页类似，区别在于减少了供用户复合查询的字段以及查询时间热度分析

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210627135508124.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTcxNjg5MQ==,size_16,color_FFFFFF,t_70#pic_center)


#### 4、分词查询后端

get_news_split_info路由：

首先，调用函数 get_split_word 获得分词后的结果，对查询内容进行分词，并去除停用词

```js
// 分词模块
var Segment = require('segment')
var segment = new Segment()    // 创建实例
segment.useDefault()
// 加载停用词
segment.loadStopwordDict('stopword.txt')

// 对查询内容进行分词，并去除停用词
function get_split_word(query){
    var result = segment.doSegment(query, {
        stripStopword: true,   // 去除停用词
        simple: true
    })
    console.log(result)
    return result
}
```

然后，将分词后的结果插入数据库中，并且构建查询语句（若分词结果为”疫情“和”中国“，则查询语句为”疫情|中国“），考虑到用户可能不输入查询语句，这时将默认为全范围查询，所以将查询语句设置为”|“

```js
// 将用户查询词插入数据库
var search_title = ""   // 构建查询语句
for (const v_title of split_title){
    var searchSql = 'INSERT INTO newssearch(title)' + ' VALUES (?)'
    var searchSql_Params = [v_title] 
    mysql.query(searchSql, searchSql_Params, function(err, result, fields) {
        if (err) console.log(err)
    })
    search_title += v_title + "|"
}
search_title = search_title.substring(0, search_title.length - 1)
if (split_title.length == 0) search_title = "|"
```

最后，通过mysql中的rlike关键字，来获取包含任一关键词的新闻数据，其中可以进行标题和内容字段的复合查询

```mysql
var fetchSql = "select url,source,title,author,cast(date_format(publish_date,'%Y-%m-%d') as char) as new_publish_date from news_info where title RLIKE '" + search_title + "' and content RLIKE '" + search_content + "'";
```

#### 5、未分词与分词查询对比

以标题查询 ”中国的疫苗“ 为例，在未分词查询时，其为匹配到对应的查询内容，召回率很低

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210627135546998.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTcxNjg5MQ==,size_16,color_FFFFFF,t_70#pic_center)


在分词查询时，虽然返回的一些新闻与查询字段匹配度不是很高，但其召回率较高，提供了很多相关的新闻供用户进行参考

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210627135559188.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTcxNjg5MQ==,size_16,color_FFFFFF,t_70#pic_center)


### 六、查询结果按主题词打分进行排序

通过对用户的查询内容分词后，其虽然提高了召回率，但降低了准确率，使得与查询内容不那么相匹配的内容返回，所以需通过对返回内容按照与主题词相关度来进行打分并排序，将更相关的内容排至前面

#### 1、打分机制

这里采用的是 $tf-idf$ 打分机制

 $tf$ 指某一词语在该文件中出现的频率，若词语在该文件中出现的频率越多，即 $tf$ 越大，文档越相关

$df$ 指包含词语的文件在所有文件中出现的频率，当包含词语的文件越多，该词语具备区分文档的能力越弱，即 $df$ 越大，文档越不相关，而 $idf = log{\frac{1}{df}}$

计算公式：TF-IDF = TF × IDF​，TF-IDF​ 值越大表示该词语对这个文本的重要性越大

#### 2、打分实现

由于对符合查询内容进行打分有点复杂，所以这里选择用户输入的标题作为主题词进行打分

由于三种新闻的打分实现较为相似，所以这里以中国广播网为例：

**首先**，对中国新闻网数据的标题字段进行分词，将新闻id以及对应的分词存入表格 news_title_split_word 中

news_title_split_word 表格结构：

```sql
CREATE TABLE IF NOT EXISTS `news_title_split_word` (
  `id` int(11)  NOT NULL AUTO_INCREMENT,
  `news_id` varchar(200) ,
  `word` varchar(200) ,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

表格内容：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210627135609482.png#pic_center)


分词代码：

```js
// 对中国广播网的 title 内容进行分词
function news_split_word(){
    var fetchSql = "select id,title from news_info"
    mysql.query_noparam(fetchSql, function(err, result, fields) {
        for (var i = 0; i < result.length; i++) {
            //console.log(result[i]['title'])
            // 对标题进行分词，将分词结果和其对应的id存入表news_title_split_word中
            var the_id = result[i]['id']
            var the_title = result[i]['title']
            // 进行分词
            var the_result = get_split_word(the_title)
            for (const v_title of the_result){
                // 插入分词结果
                var searchSql = 'INSERT INTO news_title_split_word(news_id,word)' + ' VALUES (?,?)'
                var searchSql_Params = [the_id,v_title] 
                mysql.query(searchSql, searchSql_Params, function(err, result, fields) {
                    if (err) console.log(err)
                })
            }
        }
    })
}
```

**然后**，分别计算每个单词在每个文档中的 $tf$ 和 $idf$ 值，其中 $tf$ 需计算该单词在该文档中出现的次数以及该文档包含的总分词数，$idf$ 需计算出现该单词的总文档数以及新闻数据的总文档数，由于总文档数均是相同的，其只需计算一次即可**（注意 sql 语句中的中文需添加单引号）**

**该单词在该文档中出现的次数**："select count(*) as num3 from news_title_split_word where news_id=" + the_news_id + " and word='" + the_word + "'"

**该文档包含的总分词数**："select count(*) as num2 from news_title_split_word where news_id=" + the_news_id

**出现该单词的总文档数**："select count(distinct news_id) as num4 from news_title_split_word where word='" + the_word + "'"

**新闻数据的总文档数**："select count(*) as num1 from news_info"

**之后**，遍历 news_title_split_word 表中的新闻id和单词，计算相对应的权重，存入表格 news_title_word_weight 中

news_title_word_weight 表格格式：

```sql
CREATE TABLE IF NOT EXISTS `news_title_word_weight` (
  `news_id` varchar(200) ,
  `word` varchar(200) ,
  `weight` DOUBLE,
  PRIMARY KEY (`news_id`,`word`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

表格内容：

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210627135622617.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTcxNjg5MQ==,size_16,color_FFFFFF,t_70#pic_center)


计算打分代码：

```js
// 计算中国广播网 title 分词后的权重 (tf-idf)
function news_word_weight(){

    // 由于总文档数均相等，计算一遍即可
    var total_document    // 总文档数
    var total_document_sql = "select count(*) as num1 from news_info"
    mysql.query_noparam(total_document_sql, function(err, result, fields) {
        //console.log(result)
        total_document = result[0]['num1']

        // 获取 文档id-单词的所有数据，计算某个单词在某个文档中的权重
        var fetchSql = "select news_id,word from news_title_split_word"
        mysql.query_noparam(fetchSql, function(err, result, fields) {
            result.forEach(function(item){
                var the_news_id = item['news_id']
                var the_word = item['word']
                //console.log(the_news_id)
                //console.log(the_word)

                // tf值：单词在文章中出现次数对应文章总单词数的占比
                var total_frequency    // 文章总单词数
                var total_fre_sql = "select count(*) as num2 from news_title_split_word where news_id=" + the_news_id
                mysql.query_noparam(total_fre_sql, function(err, result, fields) {
                    //console.log(result)
                    total_frequency = result[0]['num2']

                    var word_frequency   // 单词在文章中出现次数
                    var word_fre_sql = "select count(*) as num3 from news_title_split_word where news_id=" + the_news_id + " and word='" + the_word + "'"
                    mysql.query_noparam(word_fre_sql, function(err, result, fields) {
                        //console.log(result)
                        word_frequency = result[0]['num3']

                        var tf = word_frequency / total_frequency

                        // idf值：包含word的文档数量在总文档数中占比
                        var word_document    // 包含word的文档数量
                        var word_document_sql = "select count(distinct news_id) as num4 from news_title_split_word where word='" + the_word + "'"
                        mysql.query_noparam(word_document_sql, function(err, result, fields) {
                            //console.log(result)
                            word_document = result[0]['num4']

                            var idf = word_document / total_document

                            // 计算最终权重
                            var final_weight = tf * Math.log(1 / idf)
                            // 插入权重结果
                            var weightSql = 'INSERT INTO news_title_word_weight(news_id,word,weight)' + ' VALUES (?,?,?)'
                            var weightSql_Params = [the_news_id,the_word,final_weight] 
                            mysql.query(weightSql, weightSql_Params, function(err, result, fields) {
                                if (err) console.log(err)
                            })
                        })
                    })
                })
            })
        })
    })    
}
```

**最后**，修改 get_finance_split_info 路由，在用户输入标题时，计算每个文档对应的分数，对其排序返回至前端，若用户未输入标题，则不对结果排序

这里通过 sql 语言来实现计算文档分数并排序，将分词权重表 news_title_word_weight 和新闻信息表 news_info 根据id连接，选取包含查询关键词的文档id，将结果按照文档id分组，累加权重的值，最后按照权重值降序排列

```js
// 将分词权重表和新闻信息表根据id连接，选取包含查询关键词的文档id，再计算每个id的得分，最后根据得分排序，返回至前端
var scoreSql = "select id,url,source,title,author,cast(date_format(publish_date,'%Y-%m-%d') as char) as new_publish_date,sum(weight) from news_info,news_title_word_weight where news_info.id = news_title_word_weight.news_id and word RLIKE '" + search_title + "' group by news_info.id order by sum(weight) desc"
mysql.query(scoreSql, function(err, result, fields) {
    response.writeHead(200, {
        "Content-Type": "application/json"
    })
    response.status = true;
    response.write(JSON.stringify(result));
    response.end()
})
```

#### 3、打分排序前后对比

标题查询 “创新才能”

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210627135635678.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTcxNjg5MQ==,size_16,color_FFFFFF,t_70#pic_center)


在打分排序后，包含两个分词结果的文档id权重相较于一个分词的更高，其排序更加靠前

### 七、实验中遇到的问题以及需要注意的点

 1. 在使用POST方法进行前后端传参时，发现页面始终没有反应，原以为是使用POST方法存在问题，所以在检查POST方法上花了很多时间，后来通过前端发现是未引用jquery库jquery.min.js文件的原因
 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210627135727814.png#pic_center)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210627135727854.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTcxNjg5MQ==,size_16,color_FFFFFF,t_70#pic_center)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20210627135727769.png#pic_center)


 2. 在前端处理POST方法返回的数据时，误以为数据为JSON类型，用JSON方式进行解析后，产生以下报错信息

    ![在这里插入图片描述](https://img-blog.csdnimg.cn/2021062713583445.png#pic_center)
    ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210627135846762.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTcxNjg5MQ==,size_16,color_FFFFFF,t_70#pic_center)

    后来才发现数据为object类型，解析数据的方式出现问题

    ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210627135907566.png#pic_center)
    ![在这里插入图片描述](https://img-blog.csdnimg.cn/20210627135915324.png#pic_center)

 3. 在检查POST方法问题的时候，发现.post()是异步执行的，会产生开启异步执行.post()后，function query()继续往下执行，然后结束了自己，等.post()执行完回调的时候，function query()已经结束了，从而无法执行的情况，所以使用POST方法的时候，最好使用$.ajax()，并将异步执行关掉

    ```html
    // 将用户名和密码传递至user_register路由，从而判断用户是否已经注册
    $.ajax({
        url: "/user_register",
        async: false,        //这一步是非常重要的，作用是设置为同步执行
        type: "POST",
        data: { name:username.value,pwd:password.value },
        dataType: "json",
        success: function (data) {
            // 后端传递内容的类型为object，直接进行解析
            console.log(typeof(data))
            console.log(data)
            var status = data['status']
            window.alert(status)
            // 转跳登录页面   
            window.location.href = "http://localhost:3000/login.html"
        }
    })
    ```

 4. 在从修改后的user_info表中提取ban字段来判断是否可以对用户进行停用或启用操作时，通过后端打印，发现获得的只有用户名和密码字段，后经检查发现，是因为写了两个user_login路由，所以访问的路由是先前未经过修改的路由

 5. 为了防止用户直接通过输入网址，跳过登录操作来进行数据的查看或者管理员的界面访问，需要使用cookie缓存用户的用户名，然后在数据查询和管理员界面开头就进行用户名的检查，判断是否为已经登录的用户或管理员

 6. 在计算每个词项在每个文档中的权重（news_word_weight 函数）时，尝试将mysql查询获得的结果赋值给变量，但发现变量的值一直为原本初始化的值，最终发现mysql异步调用使得其无法将结果赋值，所以最后直接在mysql查询内容中进行操作，代替了结果赋值后再处理

 7. 在对每个文档进行打分时，最初想法是先获得符合查询内容的文档id，再循环每个文档id，循环每个词项，通过获得每个词项在文档中的权重，进行累加来计算文档的总权重，这种方法会多次调用数据库，并且需要使用变量存储每个词项的权重，但是mysql异步使其无法赋值，通过查阅资料，发现可以通过promise的方法来赋值，但是promise的返回值也因为异步无法赋值，只能通过 async/await 方法来赋值，但是在使用 async/await 方法运行会卡住，所以最终放弃了这个想法，也因此在这里浪费了很多时间

    解决mysql赋值问题可参考：https://blog.csdn.net/weixin_43889562/article/details/99603030

    解决promise赋值问题可参考：https://ask.csdn.net/questions/7414188

 8. 最终，在对每个文档进行打分时，将所有的内容通过 mysql 语句来实现，从而避免多次调用数据库处理带来的异步问题，与此同时，这种方法减少了与数据库交互的次数，性能也更加的好

### 八、总结与感想

1. 通过用户注册登录要求的实现，了解了使用 cookie 机制来判断用户是否已经登录，再将页面显示给用户
2. 在打分排序要求的实现中，虽然最初的想法过于复杂，难以实现，但是深刻体会到了nodejs中的异步机制，它虽然能够使得事件I/O非阻塞，使CPU与I/O并不相互依赖等待，让资源得到更好的利用，但当用户需要某事件等待另一个事件执行完后再执行时，即两事件同步，编程会变得复杂，我也是因为nodejs的异步机制，在实现打分排序要求中花费了大量时间
3. 在考虑使用tf-idf算法实现打分排序前，有了解到Elastic Search中存在搜索排序的接口，但是因为对于Elastic Search不太熟悉，所以最终还是选择自己编写tf-idf算法来进行打分排序

